Class ZooKeeper
这是ZooKeeper客户端库的主要类。为了使用ZooKeeper服务，一个应用必须首先实例化该类的一个对象。所有的请求都通过调用该类的方法来完成。除了其他说明外，该类的方法都是线程安全的。

一旦到服务器的连接被建立，一个Session ID会被传到客户端（指定是ZooKeeper客户端库，而非应用程序），客户端会周期性地向服务器发送心跳来保持Session的合法性。

只要客户端的Session ID是合法的，应用程序都可以通过客户端来调用ZooKeeper的API

如果由于某些原因，客户端在较长时间内（超过了会话超时时间）无法向服务器发送心跳，服务器将使Session超时，Session ID将变成非法的。客户端对象不再可用。这时应用程序必须创建一个新的客户端对象，才可以使用ZooKeeper的API

如果客户端当前连接的服务器无法再连接或不能响应，在客户端的Session ID超时前将自动尝试连接其它服务器，如果成功，应用程序可以继续使用这个客户端。


一些ZooKeeper API成功调用后可以在ZooKeeper服务器里的数据节点上留下（设置）Watch。其它的ZooKeeper API成功调用后可以触发那些Watch。一旦一个Watch被触发，一个事件将被分发到最初留下Watch的那个客户端。每个Watch只能被触发一次。对于客户端留下的每个Watch，最多会有一个事件分发过来。

当客户端丢弃当前的连接，且重新连接到一个服务器，所有存在的Watch被认为触发，但是非分发的事件都会丢失。为了模拟这个，客户端将产生一个特别的事件来告诉事件处理器一个连接已经被放弃，事件类型是None，ZooKeeper状态是Disconnected。

Session的建议是异步的，构造函数只是初始化一个到服务器的连接就马上返回，这时通常Session还没有完全建立。如果状态发生任何改变，构造函数中的Watch将会被通知。这个通知可能会随时到来，可能构造函数还没执行完就已到来。

除非Session是显式关闭的（表明不再想使用），否则由于网络造成的断开，客户端会一直尝试连接服务器。

chroot可以指定一个路径，所有客户端API中路径都是基于这个指定的路径来计算。

在已经建立的连接上使用 getSessionId()和getSessionPasswd()可以获得Session ID和Session Password，当重新连接时需要把它们传给服务器，表明想使用之前的那个Session（前提时那个Session还未超时）。

ZooKeeper Sessions
客户端创建一个到服务器的句柄，然后开始尝试连接服务器，此时状态是CONNECTING（连接中），一旦连接建立后状态就变为CONNECTED（已连接）

服务器创建一个Session时，会创建一个Session ID和Password发给客户端，当客户端重新连接到一个不同的服务器且还使用已建立的那个Session时，需要传递这两个参数。

等客户端从服务集群断开时，它会搜索服务器列表尝试重新连接。最后当连接重新建立后，Session要么是已连接状态（在超时时间内重新建立好了连接），或者是超时状态（在超时后才重新建立好连接）。当连接断开后，重新创建一个新的Session对象是不明智的，客户端库会为你处理重连。特别地，我们已经启发式地构建客户端库来处理像羊群效应这些事情。只有在你收到Session超时通知的时候才创建一个新的Session。

Session超时是由ZooKeeper集群自己管理的，而不是客户端。集群使用建立连接时指定的超时时间来决定客户端Session什么时候超时。当在指定的超时时间周期内集群接受不到来自客户端的心跳，超时即发生。在超时发生时，集群将删除该Session拥有的所有临时节点和立即通知那些在这些临时节点上放置有Watch的处于连接状态的客户端。在这时这个超时的Session所对应的客户端仍然和集群是断开状态，它将不会收到Session超时通知，直到/除非它能够和集群重新建立一个连接。客户端将处于断开状态直到和集群的连接被重新建立，在那时超时Session的Watcher将收到一个Session超时的通知。

正常连接状态->客户端从集群分开->断开状态->时间流逝，集群使Session超时（客户端什么都不知道，因为它和集群是断开的）->时间流逝，客户端（使用原来的Session ID和Password）重新和集群建立了连接->最后收到了Session超时通知。

在Session建立时有一个参数是默认的Watcher。当客户端的状态发生任何改变时Watcher都会被通知。例如客户端丢失和服务器之间的链接时或客户端Session超时。这个Watcher应该被认为初始状态是断开，对于一个新连接，发送给Watcher的第一个事件是典型的Session已建立连接事件。

客户端发送请求来保持Session的存活，如果空闲了一段即将超时的时间，客户端将发送一个PING请求来保持Session存活。这个PING请求不仅让服务器知道客户端是存活的，也让客户端验证它自己到服务器的连接是存活的。PING的时机是足够的保守来确保一个合理的时间去检测连接是否不再存活和重新连接到一个新的服务器。

一旦到服务器的连接建立，只有两种基本的情况下客户端会产生连接丢失（将抛出异常），在一个不再存活的Session上执行同步操作；客户端和服务器断开连接时，还有到服务器的未完成的异步操作。

有一个内部异常一般客户端不可见叫做SessionMovedException。这个异常发生的原因是服务器通过Session连接收到一个请求时这个Session已经和另一个不同的服务器重新建立了连接。通常的原因是客户端向服务器发送了一个请求，但是网络数据包存在延迟，所以客户端超时了又连接到另一个新的服务器。当延迟的数据包到达第一个旧服务器，这个服务器检测到Session已经转移，然后会关闭到客户端的连接。客户端通常看不到这个错误，因为它不再从那个旧连接读取数据（旧连接通常已经被关闭）。

ZooKeeper Watch
ZooKeeper中所有的读操作都可以设置Watch。这些Watch只会被触发一次，如果还想被触发，就需要再调用一次读操作来设置Watch。

在节点修改操作的成功返回码到达引起这次修改操作的客户端前，事件不会到达在该节点上设置Watch的客户端。Watch是异步发送给Watcher的。ZooKeeper提供一个顺序保证，客户端将绝对看不到它设置有Watch的节点的变化直到客户端首次收到Watch事件。由于网络延迟和其它因素导致不同的客户端收到Watch事件的时间不同，但是不同的客户端看到的所有事情将有一致的顺序。

这涉及到一个节点能够被改变的不同方式，帮助我们理解ZooKeeper维护两个Watch列表，data watch和child watch。getData()和exists()设置data watch。getChildren()设置child watch。帮助理解正在被设置的Watch依据于返回数据的种类。getData()和exists()返回有关节点数据的信息，getChildren()返回孩子列表。setData()将触发节点上设置的data watch。create()将触发正在被创建的节点上设置的data watch和该节点的父节点上设置的child watch。delete()将触发正在被删除的节点上设置的data watch和该节点的父节点上设置的child watch。

Watch是由客户端连接的那个服务器维护在自己本地。这允许Watch的设置、维护和分发是轻量级的。当一个客户端连接到一个新的服务器上，对于任何的Session事件Watch都会被触发。当和服务器断开时是不会收到Watch的。当一个客户端重新建立了连接，如果需要的话，任何之前注册过的Watch将会被重新注册和触发。通常这些对客户端来说都是透明发生的。有一种情况Watch可能会丢失，对于一个还没有创建的节点的exist的Watch将被丢失，如果这个节点被创建随后又删除，且期间客户端一直是断开着的。

Semantics of Watches
三个读取ZooKeeper状态的方法exists、getData和getChildren可以设置Watch。exist方法设置的Watch可以收到Created事件。exist、getData和getChildren方法设置的Watch可以收到Deleted事件。exist和getData方法设置的Watch可以收到Changed事件。getChildren设置的Watch可以收到Child事件。

What ZooKeeper Guarantees about Watches
关于Watch，ZooKeeper维护了这些保证。相对于其它事件、其它watch和异步回复，Watch是有顺序的。客户端库会确保所有的事情按顺序被分发。客户端如果设置了Watch的话，在看到一个节点的新数据之前会先收到一个Watch事件。来自于ZooKeeper的Watch事件顺序和ZooKeeper服务中的更新操作顺序是一一对应的。

Things to Remember about Watches
Watch是一次触发的，如果你收到一个Watch事件，且以后还需收到，就必须重新设置一次。

在收到事件和重新设置Watch之间会存在延迟，因此不能可靠地看到节点的所有改变。做好准备处理这种情况，就是在收到事件和再次设置Watch之间节点已改变多次（可以不用关心，至少认识到这可能发生）。

对于一个给定的通知，同一个Watch对象只会被触发一次。例如，如果同一个Watch对象被exists和getData对同一个节点注册了两次，此时节点被删除，对于这个删除通知，Watch对象只会被调用一次（不会重复调用两次）。

与服务器断开连接后，将收不到任何Watch通知直到连接重新建立。基于这个原因，Session事件会发送给所有优秀的事件处理者。使用Session事件来进入一个安全模式，断开连接时收不到事件，这种模式下你的处理应该谨慎地执行。

ZooKeeper access control using ACLs
ZooKeeper使用ACL来控制访问它的节点，与UNIX文件访问权限相似，不同的是没有拥有者、组和其它这样的概念，一个ACL指定ids和与之关联的权限的集合。

一个ACL只和一个指定的节点相关。特别地它并不应用于孩子。ACL不是递归的。

ZooKeeper支持可插拔的认证方案。Ids被指定使用scheme:id这样的形式，例如，ip:172.16.16.1采用ip认证。

当客户端连接到ZooKeeper且自己已经认证，ZooKeeper把与客户端相对应的所有ids关联到客户端连接上。当客户端尝试访问节点时，这些ids就会与节点的ACL进行对比验证。ACL是由若干对（方案:表达式，权限）组成。表达式的格式对于方案来说是特定的。例如，（ip:19.22.0.0/16，READ）给所有IP地址以19.22开始的客户端读的权限。

ACL Permissions
支持以下权限，CREATE，创建子节点。READ，获取节点数据和列出子节点。WRITE，更新节点数据。DELETE，删除子节点。ADMIN，设置权限。

为了细粒度的访问控制，create和delete权限已经打破write权限。你希望可以更新节点数据，但不能创建和删除子节点。可以创建子节点但不能删除。由于ZooKeeper没有拥有者概念，所以admin权限就类似拥有者。ZooKeeper不支持查看权限（就是看一下有哪些权限），因为默认都有查看权限，这允许你看一个节点的stat，但仅此而已。（问题是，对于一个不存在的节点调用exist()方法，没有权限会被检查）。

Builtin ACL Schemes


Consistency Guarantees
ZooKeeper是一个高性能、可扩展服务。读和写操作都被设计的很快，虽然读比写更快。
顺序一致性，来自同一个客户端的更新操作将按照被发送的顺序执行。原子性，要么成功要么失败。单一系统镜像，客户端无论连接哪个服务器看到的视图都是一样的。可靠性，一旦一个更新被执行，它将持久化存在直到下次再被更新。这个保证有两个推论，如果一个客户端收到一个成功返回码，更新将已经被执行。在某些情况（通信错误、超时）客户端不知道更新是否执行。我们采取措施来最小化失败，但是保证只会随着成功返回码存在（有成功返回码时一定保定成功）（这叫单调性情况）。当服务器从失败恢复时，之前客户端看到的任何更新都不会被回滚。及时性，在一个确定的时间范围内，系统的客户端视图被保证是最新的。要么客户端看到系统改变，要么客户端检测到服务中断。

ZooKeeper不能保证夸客户端同时一致性（不同的客户端在同一时刻看到的视图可能是不一致的），一个客户端更新了节点的值，然后告诉另一个客户端来读该节点的值，有可能读到的是旧值，取决于它连的是那一个服务器。如果必须保证读取到新的值，那么先调用sync()方法让服务器同步一下数据，然后再读取数据。因此ZooKeeper不能保证改变发生同步地横跨集群中所有服务器，但是ZooKeeper基本能够被用于构建高级别功能，像提供有用的客户端同步（分布式同步）。